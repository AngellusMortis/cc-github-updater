local a=require("cc.expect")local b={}b.p={}b.p.root="/"b.p.base="/ghu/"if fs.exists("/disk/ghu")then b.p.base="/disk/ghu/"end;b.p.base=settings.get("ghu.base","/ghu/")if string.sub(b.p.base,1,string.len(5))=="/disk"then b.p.root="/disk/"end;b.p.core=b.p.base.."core/"b.p.ext=b.p.base.."ext/"local c=require(b.p.core.."apis/am/core")local d=pcall(function()require("am.core")end)local e=shell.resolveProgram("ghuconf")local f={}f={}f.base={name="ghu.base",default=b.p.base,type="string",description="The base path for cc-updater. Recommendeded not to change."}f.autoUpdate={name="ghu.autoUpdate",default=true,type="boolean",description="Auto-update cc-updater repos on computer boot."}f.autoRun={name="ghu.autoRun",default=true,type="boolean",description="Allow extra repos to provide auto-run programs."}f.coreRepo={name="ghu.coreRepo",default="AngellusMortis/cc-updater@v1:/src",type="string",description="Core repo for cc-updater. Recommended not to change."}f.extraRepos={name="ghu.extraRepos",default={},type="table",description="List of extra cc-updater repos."}f.minified={name="ghu.minified",default=true,type="boolean",description="Download minfied Lua files"}b.s=c.makeSettingWrapper(f)_G.ghuStartupRan=false;local function g(h,i)a.expect(1,h,"string")a.expect(2,i,"string","nil")local j=b.p.ext..h;if h=="core"then j=b.p.core;i=""end;if i==nil or i==""then i="/src"end;i=i:gsub("/src","")if i:sub(1,1)=="/"then i=i:sub(2)end;if j:sub(#j,#j)~="/"then j=j.."/"end;j=j..i;if j:sub(#j,#j)~="/"then j=j.."/"end;return j end;local function k(l)a.expect(1,l,"string")local m=l=="core"if m then l=b.s.coreRepo.get()end;local n=c.split(l,":")local h=n[1]local o="master"local i="/"if#n==1 then i="/src"elseif#n>2 then error("Bad repo path: "..l)else h=n[1]i=n[2].."/"end;n=c.split(h,"@")if#n==1 then o="master"elseif#n>2 then error("Bad repo ref: "..l)else h=n[1]o=n[2]end;if i:sub(#i,#i)~="/"then i=i.."/"end;return g(m and"core"or h,i),h,o,i end;local function p(l)a.expect(1,l,"string")local j=k(l)return j.."manifest"end;local function q(l)a.expect(1,l,"string")local r=p(l)if not fs.exists(r)then return{files={}}end;local s=fs.open(r,"r")local t=textutils.unserialize(s.readAll())if t.files==nil then t={files=t}end;s.close()return t end;local function u(l,t)a.expect(1,l,"string")local r=p(l)if fs.exists(r)then fs.delete(r)end;local s=fs.open(r,"w")s.write(textutils.serialize(t))s.close()end;local function v(l)a.expect(1,l,"string")local m=l=="core"local w,h,o,i=k(l)print("."..h)print("..ref:"..o..".path:"..i)print("..dest:"..w)local x="https://raw.githubusercontent.com/"..h.."/"..o..i.."/"local t=c.getJSON(x.."manifest.json")local y=q(l)local z=0;local A=1;if t.dependencies~=nil and#t.dependencies>0 then print("..deps:"..tostring(#t.dependencies))print("..startdeps:"..h..i)for B,C in ipairs(t.dependencies)do local D,E=v(C)z=z+D;A=A+E end;print("..enddeps:"..h..i)end;for j,F in pairs(t.files)do if j=="startup.lua"and not m then error("Only coreRepo can set startup.lua")end;if F~=y.files[j]then print("..."..j)local G=j;if b.s.minified.get()then G=G:gsub("%.lua",".min.lua")end;if j=="startup.lua"then c.download(x..G,b.p.root..j)else c.download(x..G,w..j)end;z=z+1 end end;print("..total: "..tostring(z))u(l,t)return z,A end;local function H(l,t)a.expect(1,l,"string")a.expect(2,t,"table","nil")if t==nil then t=q(l)end;if t==nil then error("Could not load manifest")return end;local I={}if t.dependencies==nil then return I end;for B,J in ipairs(t.dependencies)do I=c.concat(I,H(J))I[#I+1]=J end;return I end;local function K()local L={}for M,l in ipairs(b.s.extraRepos.get())do local j=k(l)local N=j.."autorun/"L=c.concat(L,fs.find(N.."*.lua"))end;return L end;local function O(l)a.expect(1,l,"string")local j=k(l)local P=shell.path()local w=":"..j;help.setPath(help.path()..w.."help")w=w.."programs/"P=P..w;if term.isColor()then P=P..w.."advanced"end;if turtle then P=P..w.."turtle"else P=P..w.."rednet"P=P..w.."fun"if term.isColor()then P=P..w.."fun/advanced"end end;if pocket then P=P..w.."pocket"end;if commands then P=P..w.."command"end;if http then P=P..w.."http"end;shell.setPath(P)end;local function Q(R)a.expect(1,R,"boolean","nil")if R==nil then R=false end;if e and not R then return end;O("core")local S={["core"]=true}for M,l in ipairs(b.s.extraRepos.get())do if S[l]==nil then O(l)S[l]=true end;local I=H(l)for B,T in ipairs(I)do O(T)end end end;local function U(l)a.expect(1,l,"string")local j=k(l)local V=package.path;local w=";"..j;V=V..w.."apis/?"V=V..w.."apis/?.lua"V=V..w.."apis/?/init.lua"package.path=V end;local function W(R)a.expect(1,R,"boolean","nil")if R==nil then R=false end;if d and not R then return end;U("core")local S={["core"]=true}for M,l in ipairs(b.s.extraRepos.get())do if S[l]==nil then U(l)S[l]=true end;local I=H(l)for B,T in ipairs(I)do U(T)end end;d=true end;b.parseRepo=k;b.getRepoPath=g;b.getManifestPath=p;b.readManifest=q;b.writeManifest=u;b.updateRepo=v;b.getDeps=H;b.getAutoruns=K;b.addShellPath=O;b.initShellPaths=Q;b.addModulePath=U;b.initModulePaths=W;Q()W()return b
