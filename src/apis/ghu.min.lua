local a=require("cc.expect")local b={}b.p={}b.p.root="/"b.p.base="/ghu/"if fs.exists("/disk/ghu")then b.p.base="/disk/ghu/"end;b.p.base=settings.get("ghu.base","/ghu/")if string.sub(b.p.base,1,string.len(5))=="/disk"then b.p.root="/disk/"end;b.p.core=b.p.base.."core/"b.p.ext=b.p.base.."ext/"local c=require(b.p.core.."apis/am/core")local d=pcall(function()require("am.core")end)local e=shell.resolveProgram("ghuconf")local f={}f={}f.base={name="ghu.base",default=b.p.base,type="string",description="The base path for cc-updater. Recommendeded not to change."}f.autoUpdate={name="ghu.autoUpdate",default=true,type="boolean",description="Auto-update cc-updater repos on computer boot."}f.autoRun={name="ghu.autoRun",default=true,type="boolean",description="Allow extra repos to provide auto-run programs."}f.coreRepo={name="ghu.coreRepo",default="AngellusMortis/cc-updater@v1:/src",type="string",description="Core repo for cc-updater. Recommended not to change."}f.extraRepos={name="ghu.extraRepos",default={},type="table",description="List of extra cc-updater repos."}f.minified={name="ghu.minified",default=true,type="boolean",description="Download minfied Lua files"}b.s=c.makeSettingWrapper(f)_G.ghuStartupRan=false;local function g(h,i)a.expect(1,h,"string")a.expect(2,i,"string","nil")local j=b.p.ext..h;if h=="core"then j=b.p.core;i=""end;if i==nil or i==""then i="/src"end;i=i:gsub("/src","")if i:sub(1,1)=="/"then i=i:sub(2)end;if j:sub(#j,#j)~="/"then j=j.."/"end;j=j..i;if j:sub(#j,#j)~="/"then j=j.."/"end;return j end;local function k(l)a.expect(1,l,"string")local m=l=="core"if m then l=b.s.coreRepo.get()end;local n=c.split(l,":")local h=n[1]local o="master"local i="/"if#n==1 then i="/src"elseif#n>2 then error("Bad repo path: "..l)else h=n[1]i=n[2].."/"end;n=c.split(h,"@")if#n==1 then o="master"elseif#n>2 then error("Bad repo ref: "..l)else h=n[1]o=n[2]end;if i:sub(#i,#i)~="/"then i=i.."/"end;return g(m and"core"or h,i),h,o,i end;local function p(l)a.expect(1,l,"string")local j=k(l)return j.."manifest"end;local function q(l)a.expect(1,l,"string")local r=p(l)if not fs.exists(r)then return{files={}}end;local s=fs.open(r,"r")local t=textutils.unserialize(s.readAll())if t.files==nil then t={files=t}end;s.close()if t.minified==nil then t.minified=false end;return t end;local function u(l,t)a.expect(1,l,"string")local r=p(l)if fs.exists(r)then fs.delete(r)end;t.minified=b.s.minified.get()local s=fs.open(r,"w")s.write(textutils.serialize(t))s.close()end;local function v(l)a.expect(1,l,"string")local m=l=="core"local w,h,o,i=k(l)print("."..h)print("..ref:"..o..".path:"..i)print("..dest:"..w)local x="https://raw.githubusercontent.com/"..h.."/"..o..i.."/"local t=c.getJSON(x.."manifest.json")local y=q(l)local z=0;local A=1;if t.dependencies~=nil and#t.dependencies>0 then print("..deps:"..tostring(#t.dependencies))print("..startdeps:"..h..i)for B,C in ipairs(t.dependencies)do local D,E=v(C)z=z+D;A=A+E end;print("..enddeps:"..h..i)end;local F=y.minified;for j,G in pairs(t.files)do if j=="startup.lua"and not m then error("Only coreRepo can set startup.lua")end;local H=b.s.minified.get()if G~=y.files[j]or F~=H then print("..."..j)local I=j;if H then I=I:gsub("%.lua",".min.lua")end;if j=="startup.lua"then c.download(x..I,b.p.root..j)else c.download(x..I,w..j)end;z=z+1 end end;print("..total: "..tostring(z))u(l,t)return z,A end;local function J(l,t)a.expect(1,l,"string")a.expect(2,t,"table","nil")if t==nil then t=q(l)end;if t==nil then error("Could not load manifest")return end;local K={}if t.dependencies==nil then return K end;for B,L in ipairs(t.dependencies)do K=c.concat(K,J(L))K[#K+1]=L end;return K end;local function M()local N={}for O,l in ipairs(b.s.extraRepos.get())do local j=k(l)local P=j.."autorun/"N=c.concat(N,fs.find(P.."*.lua"))end;return N end;local function Q(l)a.expect(1,l,"string")local j=k(l)local R=shell.path()local w=":"..j;help.setPath(help.path()..w.."help")w=w.."programs/"R=R..w;if term.isColor()then R=R..w.."advanced"end;if turtle then R=R..w.."turtle"else R=R..w.."rednet"R=R..w.."fun"if term.isColor()then R=R..w.."fun/advanced"end end;if pocket then R=R..w.."pocket"end;if commands then R=R..w.."command"end;if http then R=R..w.."http"end;shell.setPath(R)end;local function S(T)a.expect(1,T,"boolean","nil")if T==nil then T=false end;if e and not T then return end;Q("core")local U={["core"]=true}for O,l in ipairs(b.s.extraRepos.get())do if U[l]==nil then Q(l)U[l]=true end;local K=J(l)for B,V in ipairs(K)do Q(V)end end end;local function W(l)a.expect(1,l,"string")local j=k(l)local X=package.path;local w=";"..j;X=X..w.."apis/?"X=X..w.."apis/?.lua"X=X..w.."apis/?/init.lua"package.path=X end;local function Y(T)a.expect(1,T,"boolean","nil")if T==nil then T=false end;if d and not T then return end;W("core")local U={["core"]=true}for O,l in ipairs(b.s.extraRepos.get())do if U[l]==nil then W(l)U[l]=true end;local K=J(l)for B,V in ipairs(K)do W(V)end end;d=true end;b.parseRepo=k;b.getRepoPath=g;b.getManifestPath=p;b.readManifest=q;b.writeManifest=u;b.updateRepo=v;b.getDeps=J;b.getAutoruns=M;b.addShellPath=Q;b.initShellPaths=S;b.addModulePath=W;b.initModulePaths=Y;S()Y()return b
