local a=require("cc.expect")local b={}b.p={}b.p.root="/"b.p.base="/ghu/"if fs.exists("/disk/ghu")then b.p.base="/disk/ghu/"end;b.p.base=settings.get("ghu.base","/ghu/")if string.sub(b.p.base,1,string.len(5))=="/disk"then b.p.root="/disk/"end;b.p.core=b.p.base.."core/"b.p.ext=b.p.base.."ext/"local c=require(b.p.core.."apis/am/core")local d=pcall(function()require("am.core")end)local e=shell.resolveProgram("ghuconf")local f={}f={}f.base={name="ghu.base",default=b.p.base,type="string",description="The base path for cc-updater. Recommendeded not to change."}f.autoUpdate={name="ghu.autoUpdate",default=true,type="boolean",description="Auto-update cc-updater repos on computer boot."}f.autoRun={name="ghu.autoRun",default=true,type="boolean",description="Allow extra repos to provide auto-run programs."}f.coreRepo={name="ghu.coreRepo",default="AngellusMortis/cc-updater@v1:/src",type="string",description="Core repo for cc-updater. Recommended not to change."}f.extraRepos={name="ghu.extraRepos",default={},type="table",description="List of extra cc-updater repos."}b.s=c.makeSettingWrapper(f)_G.ghuStartupRan=false;local function g(h,i)a.expect(1,h,"string")a.expect(2,i,"string","nil")local j=b.p.ext..h;if h=="core"then j=b.p.core;i=""end;if i==nil or i==""then i="/src"end;i=i:gsub("/src","")if i:sub(1,1)=="/"then i=i:sub(2)end;if j:sub(#j,#j)~="/"then j=j.."/"end;j=j..i;if j:sub(#j,#j)~="/"then j=j.."/"end;return j end;local function k(l)a.expect(1,l,"string")local m=l=="core"if m then l=b.s.coreRepo.get()end;local n=c.split(l,":")local h=n[1]local o="master"local i="/"if#n==1 then i="/src"elseif#n>2 then error("Bad repo path: "..l)else h=n[1]i=n[2].."/"end;n=c.split(h,"@")if#n==1 then o="master"elseif#n>2 then error("Bad repo ref: "..l)else h=n[1]o=n[2]end;if i:sub(#i,#i)~="/"then i=i.."/"end;return g(m and"core"or h,i),h,o,i end;local function p(l)a.expect(1,l,"string")local j=k(l)return j.."manifest"end;local function q(l)a.expect(1,l,"string")local r=p(l)if not fs.exists(r)then return{files={}}end;local s=fs.open(r,"r")local t=textutils.unserialize(s.readAll())if t.files==nil then t={files=t}end;s.close()return t end;local function u(l,t)a.expect(1,l,"string")local r=p(l)if fs.exists(r)then fs.delete(r)end;local s=fs.open(r,"w")s.write(textutils.serialize(t))s.close()end;local function v(l)a.expect(1,l,"string")local m=l=="core"local w,h,o,i=k(l)print("."..h)print("..ref:"..o..".path:"..i)print("..dest:"..w)local x="https://raw.githubusercontent.com/"..h.."/"..o..i.."/"local t=c.getJSON(x.."manifest.json")local y=q(l)local z=0;local A=1;if t.dependencies~=nil and#t.dependencies>0 then print("..deps:"..tostring(#t.dependencies))print("..startdeps:"..h..i)for B,C in ipairs(t.dependencies)do local D,E=v(C)z=z+D;A=A+E end;print("..enddeps:"..h..i)end;for j,F in pairs(t.files)do if j=="startup.lua"and not m then error("Only coreRepo can set startup.lua")end;if F~=y.files[j]then print("..."..j)if j=="startup.lua"then c.download(x..j,b.p.root..j)else c.download(x..j,w..j)end;z=z+1 end end;print("..total: "..tostring(z))u(l,t)return z,A end;local function G(l,t)a.expect(1,l,"string")a.expect(2,t,"table","nil")if t==nil then t=q(l)end;if t==nil then error("Could not load manifest")return end;local H={}if t.dependencies==nil then return H end;for B,I in ipairs(t.dependencies)do H=c.concat(H,G(I))H[#H+1]=I end;return H end;local function J()local K={}for L,l in ipairs(b.s.extraRepos.get())do local j=k(l)local M=j.."autorun/"K=c.concat(K,fs.find(M.."*.lua"))end;return K end;local function N(l)a.expect(1,l,"string")local j=k(l)local O=shell.path()local w=":"..j;help.setPath(help.path()..w.."help")w=w.."programs/"O=O..w;if term.isColor()then O=O..w.."advanced"end;if turtle then O=O..w.."turtle"else O=O..w.."rednet"O=O..w.."fun"if term.isColor()then O=O..w.."fun/advanced"end end;if pocket then O=O..w.."pocket"end;if commands then O=O..w.."command"end;if http then O=O..w.."http"end;shell.setPath(O)end;local function P(Q)a.expect(1,Q,"boolean","nil")if Q==nil then Q=false end;if e and not Q then return end;N("core")local R={["core"]=true}for L,l in ipairs(b.s.extraRepos.get())do if R[l]==nil then N(l)R[l]=true end;local H=G(l)for B,S in ipairs(H)do N(S)end end end;local function T(l)a.expect(1,l,"string")local j=k(l)local U=package.path;local w=";"..j;U=U..w.."apis/?"U=U..w.."apis/?.lua"U=U..w.."apis/?/init.lua"package.path=U end;local function V(Q)a.expect(1,Q,"boolean","nil")if Q==nil then Q=false end;if d and not Q then return end;T("core")local R={["core"]=true}for L,l in ipairs(b.s.extraRepos.get())do if R[l]==nil then T(l)R[l]=true end;local H=G(l)for B,S in ipairs(H)do T(S)end end;d=true end;b.parseRepo=k;b.getRepoPath=g;b.getManifestPath=p;b.readManifest=q;b.writeManifest=u;b.updateRepo=v;b.getDeps=G;b.getAutoruns=J;b.addShellPath=N;b.initShellPaths=P;b.addModulePath=T;b.initModulePaths=V;P()V()return b
