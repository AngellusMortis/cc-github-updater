local a=require("cc.expect")local b={}b.p={}b.p.root="/"b.p.base="/ghu/"if fs.exists("/disk/ghu")then b.p.base="/disk/ghu/"end;b.p.base=settings.get("ghu.base","/ghu/")if string.sub(b.p.base,1,string.len(5))=="/disk"then b.p.root="/disk/"end;b.p.core=b.p.base.."core/"b.p.ext=b.p.base.."ext/"local c=require(b.p.core.."apis/am/core")local d=pcall(function()require("am.core")end)local e=shell.resolveProgram("ghuconf")local f={}f={}f.base={name="ghu.base",default=b.p.base,type="string",description="The base path for cc-updater. Recommendeded not to change."}f.autoUpdate={name="ghu.autoUpdate",default=true,type="boolean",description="Auto-update cc-updater repos on computer boot."}f.autoRun={name="ghu.autoRun",default=true,type="boolean",description="Allow extra repos to provide auto-run programs."}f.coreRepo={name="ghu.coreRepo",default="AngellusMortis/cc-updater@v2",type="string",description="Core repo for cc-updater. Recommended not to change."}f.extraRepos={name="ghu.extraRepos",default={},type="table",description="List of extra cc-updater repos."}f.minified={name="ghu.minified",default=true,type="boolean",description="Download minfied Lua files"}b.s=c.makeSettingWrapper(f)_G.ghuStartupRan=false;local function g(h,i)a.expect(1,h,"string")a.expect(2,i,"string","nil")local j=b.p.ext..h;if h=="core"then j=b.p.core;i=""end;if i==nil or i==""then i="/src"end;i=i:gsub("/src","")if i:sub(1,1)=="/"then i=i:sub(2)end;if j:sub(#j,#j)~="/"then j=j.."/"end;j=j..i;if j:sub(#j,#j)~="/"then j=j.."/"end;return j end;local function k(l)a.expect(1,l,"string")local m=l=="core"if m then l=b.s.coreRepo.get()end;local n=c.split(l,":")local h=n[1]local o="master"local i="/"if#n==1 then i="/src"elseif#n>2 then error("Bad repo path: "..l)else h=n[1]i=n[2].."/"end;n=c.split(h,"@")if#n==1 then o="master"elseif#n>2 then error("Bad repo ref: "..l)else h=n[1]o=n[2]end;if i:sub(#i,#i)~="/"then i=i.."/"end;return g(m and"core"or h,i),h,o,i end;local function p(l)a.expect(1,l,"string")local j=k(l)return j.."manifest"end;local function q(l)a.expect(1,l,"string")local r=p(l)if not fs.exists(r)then return{files={}}end;local s=fs.open(r,"r")local t=textutils.unserialize(s.readAll())if t.files==nil then t={files=t}end;s.close()if t.minified==nil then t.minified=false end;return t end;local function u(l,t,v)a.expect(1,l,"string")a.expect(2,t,"table")a.expect(3,v,"boolean","nil")if v==nil then v=b.s.minified.get()end;local r=p(l)if fs.exists(r)then fs.delete(r)end;t.minified=v;local s=fs.open(r,"w")s.write(textutils.serialize(t))s.close()end;local function w(l)return b.s.minified.name..string.format(".%s",l)end;local function x(l)return settings.get(w(l))end;local function y(l,z)return settings.set(w(l),z)end;local function A(l)a.expect(1,l,"string")local m=l=="core"local B,h,o,i=k(l)print("."..h)print("..ref:"..o..".path:"..i)print("..dest:"..B)local C="https://raw.githubusercontent.com/"..h.."/"..o..i;local t=c.getJSON(C.."manifest.json")local D=q(l)local E=0;local F=1;if t.dependencies~=nil and#t.dependencies>0 then print("..deps:"..tostring(#t.dependencies))print("..startdeps:"..h..i)for G,H in ipairs(t.dependencies)do local I,J=A(H)E=E+I;F=F+J end;print("..enddeps:"..h..i)end;local v=D.minified;local K=x(l)if K==nil then K=b.s.minified.get()end;for j,L in pairs(t.files)do if j=="startup.lua"and not m then error("Only coreRepo can set startup.lua")end;if L~=D.files[j]or v~=K then print("..."..j)local M=j;if K then M=M:gsub("%.lua",".min.lua")end;if j=="startup.lua"then c.download(C..M,b.p.root..j)else c.download(C..M,B..j)end;E=E+1 end end;print("..total: "..tostring(E))u(l,t,K)return E,F end;local function N(l,t)a.expect(1,l,"string")a.expect(2,t,"table","nil")if t==nil then t=q(l)end;if t==nil then error("Could not load manifest")return end;local O={}if t.dependencies==nil then return O end;for G,P in ipairs(t.dependencies)do O=c.concat(O,N(P))O[#O+1]=P end;return O end;local function Q()local R={}local S={["core"]=true}for T,l in ipairs(b.s.extraRepos.get())do if S[l]==nil then local j=k(l)local U=j.."autorun/"R=c.concat(R,fs.find(U.."*.lua"))S[l]=true end;local O=N(l)for G,V in ipairs(O)do if S[V]==nil then local j=k(V)local U=j.."autorun/"R=c.concat(R,fs.find(U.."*.lua"))S[V]=true end end end;return R end;local function W(l)a.expect(1,l,"string")local j=k(l)local X=shell.path()local B=":"..j;help.setPath(help.path()..B.."help")B=B.."programs/"X=X..B;if term.isColor()then X=X..B.."advanced"end;if turtle then X=X..B.."turtle"else X=X..B.."rednet"X=X..B.."fun"if term.isColor()then X=X..B.."fun/advanced"end end;if pocket then X=X..B.."pocket"end;if commands then X=X..B.."command"end;if http then X=X..B.."http"end;shell.setPath(X)end;local function Y(Z)a.expect(1,Z,"boolean","nil")if Z==nil then Z=false end;if e and not Z then return end;W("core")local S={["core"]=true}for T,l in ipairs(b.s.extraRepos.get())do if S[l]==nil then W(l)S[l]=true end;local O=N(l)for G,V in ipairs(O)do if S[V]==nil then W(V)S[V]=true end end end end;local function _(l)a.expect(1,l,"string")local j=k(l)local a0=package.path;local B=";"..j;a0=a0 ..B.."apis/?"a0=a0 ..B.."apis/?.lua"a0=a0 ..B.."apis/?/init.lua"package.path=a0 end;local function a1(Z)a.expect(1,Z,"boolean","nil")if Z==nil then Z=false end;if d and not Z then return end;_("core")local S={["core"]=true}for T,l in ipairs(b.s.extraRepos.get())do if S[l]==nil then _(l)S[l]=true end;local O=N(l)for G,V in ipairs(O)do if S[V]==nil then _(V)S[V]=true end end end;d=true end;b.parseRepo=k;b.getRepoPath=g;b.getManifestPath=p;b.readManifest=q;b.writeManifest=u;b.updateRepo=A;b.getDeps=N;b.getAutoruns=Q;b.addShellPath=W;b.initShellPaths=Y;b.addModulePath=_;b.initModulePaths=a1;b.getMinSettingName=w;b.getMinSetting=x;b.setMinSetting=y;Y()a1()return b
